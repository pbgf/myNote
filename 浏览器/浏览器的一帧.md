浏览器一帧(16ms)的常规流程： JS->Style->Layout->Paint->Composite 流程

## 为什么会卡顿
* 首先在 JS->Style->Layout->Paint->Composite 流程中，第一个点js，是很容易阻塞后面的渲染的，如果一帧中js执行耗时大于了16ms，那么会导致这一帧不进行渲染(丢帧)，从视觉上来看 会有卡顿现象，丢帧越严重页面越卡顿
* 第二，回流与重绘会中断渲染，浏览器将重新进行计算，这个过程如果在一帧中被频繁触发那么将会导致渲染被推迟，也会出现丢帧的情况。
* 需要注意的点是，各类博客中常常提到滚动、鼠标移动等事件，但实际上在一帧中同一类型的事件只会触发一次(浏览器优化)，所以需要注意的是，事件处理中是否会有导致频繁回流和重绘的代码，这才是导致卡顿的关键

### 回流与重绘
[频繁回流导致卡顿的demo](https://googlechrome.github.io/devtools-samples/jank/)
当 Render Tree 当中有元素的大小、布局、结构等发生改变时，就会触发回流(Layout)，每个页面在首次加载的时候都需要进行至少一次回流；

当 Render Tree 有元素属性需要更新，这些属性只是影响元素的外观、风格，那么则会触发重绘(Paint)。

重绘不一定导致回流，回流一定会导致重绘。

回流比重绘的代价要更高。

### virtual dom 卖点
当年virtual的卖点主要是说，能避免频繁的操作dom，提高页面渲染性能，但实际上这只是附带的，有经验的工程师自然会避免频繁的操作dom。virtual dom真正带来的是：声明式渲染，以及避免了直接操作dom，react会在内存中维护两个virtual dom树，最后比对出变化再反馈到真实的dom上，其思想也类似于游戏行业的双缓存模型。