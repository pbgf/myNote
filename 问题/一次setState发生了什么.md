如果调用了useState的更新函数，那么首先会创建一个update对象，描述优先级、action等信息(在传统模式下是同步优先级)，同时推入到当前fiber的等待更新队列中，然后会通过scheduleUpdateOnFiber开始进入内部的 协调流程：首先 会进入调度器，他会判断是同步还是异步任务(在react18之前，一般是同步任务)，同步任务的话会把放入到一个同步更新队列中（所有的同步任务都会放到这个更新队列中），然后经过调度后任务执行会进入到协调阶段(协调阶段主要是在内存中构造和更新fiber，更新过程主要是diff)，fiber的构建和更新过程主要涉及三个阶段：beginWork、completeWork以及Commit，在beginWork这个流程中如果是函数式组件那么会调用renderWithHooks方法，该方法会重置上下文状态变量并调用组件函数进行一次rerender，在这次函数调用中，我们的useState会被再次调用(实际调用的内部函数是updateReducer)，会执行该fiber下的等待更新队列，合并计算出最终的状态，并返回，然后函数组件会继续往下执行。然后会进行两个虚拟dom的diff，completeWork会看是否需要更新，最后在Commit阶段提交到react-dom中去实现对dom的更新
![协调流程](../react/Reconciler/fiber/image-2.png)
如果在一次事件处理函数中，连续调用了三次更新函数，那么并不会rerender三次(因为在react18之前，都是同步更新，只会通过scheduler开启一个异步任务，所有后续setState都会合并到这一个异步任务中[源码](https://github1s.com/facebook/react/blob/v17.0.1/packages/react-reconciler/src/SchedulerWithReactIntegration.new.js#L144-L145))，而是会往更新链表中推入三个update对象(每一次dispatchAction 都会往对应fiber节点的pending队列中添加update对象)，在一次react的调度循环中完成 合并计算出最终的状态。
